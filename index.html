<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js Shelf Visualizer</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #222;
            font-family: Arial, sans-serif;
        }
        canvas {
            display: block;
        }
        .controls {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 20px;
            border-radius: 5px;
            z-index: 100;
        }
        .control-group {
            margin-bottom: 15px;
        }
        label {
            display: block;
            margin-bottom: 5px;
        }
        input[type="number"], input[type="range"] {
            width: 150px;
            margin-bottom: 5px;
        }
        button {
            background: #4CAF50;
            color: white;
            padding: 8px 16px;
            border: none;
            border-radius: 3px;
            cursor: pointer;
        }
        button:hover {
            background: #45a049;
        }
    </style>
</head>
<body>
    <div class="controls">
        <h3>Shelf Configurator</h3>
        <div class="control-group">
            <button onclick="addSampleShelf()">Load Sample Configuration</button>
            <button onclick="clearShelf()">Clear Shelf</button>
        </div>
        <div class="control-group">
            <label>Add Rod:</label>
            <select id="rodPattern">
                <option value="2P_2">2P_2 (2 points, 20cm gap)</option>
                <option value="3P_22">3P_22 (3 points, 20+20cm)</option>
                <option value="3P_23">3P_23 (3 points, 20+30cm)</option>
                <option value="4P_223">4P_223 (4 points, 20+20+30cm)</option>
            </select>
            <button onclick="addRodAtPosition()">Add Rod</button>
        </div>
        <div class="control-group">
            <label>Add Plate:</label>
            <select id="plateSize">
                <option value="670">670mm (1 span)</option>
                <option value="1270">1270mm (2 spans)</option>
                <option value="1870">1870mm (3 spans)</option>
            </select>
            <button onclick="addPlateAtLevel()">Add Plate</button>
        </div>
        <div class="control-group">
            <h4>Shopping List:</h4>
            <div id="componentList">No components</div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script type="module">
        import { 
            createEmptyShelf, 
            addRod, 
            addPlate, 
            listRequiredComponents,
            CONSTANTS 
        } from './shelf-models.js';

        let currentShelf = createEmptyShelf();
        
        // Scene setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x222222);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(5, 10, 5);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        scene.add(directionalLight);

        // Materials
        const plateMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
        const rodMaterial = new THREE.MeshLambertMaterial({ color: 0x666666 });
        const attachmentMaterial = new THREE.MeshLambertMaterial({ color: 0x444444 });

        // Shelf group
        let shelfGroup = new THREE.Group();
        scene.add(shelfGroup);

        // Camera controls
        camera.position.set(2, 1.5, 2);
        camera.lookAt(0, 0, 0);

        // Constants for visualization (convert from mm to meters)
        const SCALE = 0.001; // mm to meters
        const PLATE_DEPTH = 300 * SCALE; // 300mm depth
        const PLATE_THICKNESS = 18 * SCALE; // 18mm thickness
        const ROD_DIAMETER = 12 * SCALE; // 12mm diameter
        const ATTACHMENT_SIZE = 20 * SCALE; // 20mm attachment point size

        // 3D object creation functions
        function createPlate3D(plateSize, yPosition) {
            const width = plateSize * SCALE;
            const geometry = new THREE.BoxGeometry(width, PLATE_THICKNESS, PLATE_DEPTH);
            const mesh = new THREE.Mesh(geometry, plateMaterial);
            mesh.position.y = yPosition * SCALE;
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            return mesh;
        }

        function createRod3D(rodData) {
            const group = new THREE.Group();
            const maxY = Math.max(...rodData.attachmentPoints.map(p => p.y));
            const rodHeight = (maxY + 50) * SCALE; // Add 50mm padding
            
            // Main rod
            const rodGeometry = new THREE.CylinderGeometry(ROD_DIAMETER/2, ROD_DIAMETER/2, rodHeight, 8);
            const rodMesh = new THREE.Mesh(rodGeometry, rodMaterial);
            rodMesh.position.y = (rodHeight / 2) - 25 * SCALE;
            rodMesh.castShadow = true;
            group.add(rodMesh);
            
            // Attachment points
            rodData.attachmentPoints.forEach(point => {
                const attachGeometry = new THREE.SphereGeometry(ATTACHMENT_SIZE/2, 8, 6);
                const attachMesh = new THREE.Mesh(attachGeometry, attachmentMaterial);
                attachMesh.position.y = point.y * SCALE;
                group.add(attachMesh);
            });
            
            group.position.x = rodData.position.x * SCALE;
            group.position.z = rodData.position.z * SCALE;
            return group;
        }

        // Main shelf visualization function
        function visualizeShelf() {
            // Clear existing visualization
            while(shelfGroup.children.length > 0) {
                shelfGroup.remove(shelfGroup.children[0]);
            }

            // Render rods
            for (const [rodId, rodData] of currentShelf.rods) {
                const rod3D = createRod3D(rodData);
                shelfGroup.add(rod3D);
            }

            // Render plates
            for (const [plateId, plateData] of currentShelf.plates) {
                const plate3D = createPlate3D(plateData.size, plateData.bounds.y);
                plate3D.position.x = ((plateData.bounds.x[0] + plateData.bounds.x[1]) / 2) * SCALE;
                shelfGroup.add(plate3D);
            }

            updateComponentList();
        }

        function updateComponentList() {
            const components = listRequiredComponents(currentShelf);
            const listDiv = document.getElementById('componentList');
            
            if (components.length === 0) {
                listDiv.textContent = 'No components';
            } else {
                listDiv.innerHTML = components.map(item => 
                    `${item.quantity}x ${item.component}`
                ).join('<br>');
            }
        }

        // Interactive functions
        window.addSampleShelf = function() {
            currentShelf = createEmptyShelf();
            
            // Create a sample configuration: 3P_22 pattern with plates
            const rod1 = addRod({ x: 0, z: 0 }, "3P_22", currentShelf);
            const rod2 = addRod({ x: 600, z: 0 }, "3P_22", currentShelf);
            
            addPlate(rod1, rod2, 20, 670, currentShelf);
            addPlate(rod1, rod2, 40, 670, currentShelf);
            
            visualizeShelf();
        }

        window.clearShelf = function() {
            currentShelf = createEmptyShelf();
            visualizeShelf();
        }

        let nextRodX = 0;
        window.addRodAtPosition = function() {
            const pattern = document.getElementById('rodPattern').value;
            addRod({ x: nextRodX, z: 0 }, pattern, currentShelf);
            nextRodX += CONSTANTS.ROD_HORIZONTAL_SPACING;
            visualizeShelf();
        }

        window.addPlateAtLevel = function() {
            const plateSize = parseInt(document.getElementById('plateSize').value);
            
            // Find first two adjacent rods that can support this plate
            const rodArray = Array.from(currentShelf.rods.entries()).sort((a, b) => a[1].position.x - b[1].position.x);
            
            for (let i = 0; i < rodArray.length - 1; i++) {
                const [rod1Id, rod1Data] = rodArray[i];
                const [rod2Id, rod2Data] = rodArray[i + 1];
                
                // Find common attachment levels
                const rod1Levels = new Set(rod1Data.attachmentPoints.map(p => p.y));
                const rod2Levels = new Set(rod2Data.attachmentPoints.map(p => p.y));
                const commonLevels = [...rod1Levels].filter(level => rod2Levels.has(level));
                
                if (commonLevels.length > 0) {
                    const level = commonLevels[0]; // Use first available level
                    const plateId = addPlate(rod1Id, rod2Id, level, plateSize, currentShelf);
                    if (plateId) {
                        visualizeShelf();
                        return;
                    }
                }
            }
            
            alert('Cannot add plate - need at least 2 rods with matching attachment levels');
        }

        // Initial setup and animation
        visualizeShelf();

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            
            shelfGroup.rotation.y += 0.005;
            
            renderer.render(scene, camera);
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>